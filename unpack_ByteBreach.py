data = {'name': 'ByteBreach', 'autoUpdater.py': 'import config as conf\nfrom urllib.request import urlopen as uo\nimport os\n\nupdaterCode = """\nfrom urllib.request import urlopen as uo\n\ndownloadUrl = "https://raw.githubusercontent.com/GabbaTK/ByteBreach/main/unpack_ByteBreach.py"\n\ndownload = uo(downloadUrl)\ndownload = download.read()\nexec(download)\n"""\nversionUrl = "https://raw.githubusercontent.com/GabbaTK/ByteBreach/main/version.txt"\n\nprogramVersion = conf.version\nnewVersion = uo(versionUrl)\nnewVersion = eval(newVersion.read())\n\nif newVersion > programVersion:\n    confirmation = input("A new version has been found, would you like to download it? (Y/n) >>>")\n\n    if confirmation.lower() == "y" or confirmation == "":\n        with open("update.py", "w") as update:\n            update.write(updaterCode)\n\n        os.startfile("update.py")\n', 'client.py': 'import connMan as cm\nimport config as conf\nimport os\nimport autoUpdater\n\nlocalSocket = None\nglobalSocket = None\ndiscoveredIps = [{"ip": cm.hostIp(), "name": cm.hostName()}]\ncommandLine = [""] * conf.maxCommands\nconnectedIps = [cm.hostIp()]\nconnectedProtocols = []\n\ndef connectToLocalServer():\n    global localSocket\n\n    print("Connecting to local server...")\n    print("If another window didnt start, try starting server.py")\n\n    localSocket = cm.createSocket()\n    cm.connect(localSocket, cm.hostIp(), 40500)\n\n    print("Connected!")\n\n    cm.clientSendData(localSocket, "local_hello")  \n\ndef printIps():\n    ipCounter = 0\n    for ip in discoveredIps:\n        print(ip["name"], end="   ")\n\n        ipCounter += 1\n\n        if ipCounter == conf.IPsPerLine:\n            print()\n\ndef printCommands():\n    print("-" * conf.commandLindWidth)\n\n    for command in commandLine:\n        print("|", end="")\n        print(command, end="")\n        print(" " * (conf.commandLindWidth - 2 - len(command)), end="")\n        print("|")\n\n    print("-" * conf.commandLindWidth)\n\ndef shiftCommandLine(newCommand):\n    for index, line in enumerate(commandLine):\n        if index == 0:\n            continue\n\n        commandLine[index - 1] = line\n\n    commandLine[-1] = newCommand \n\ndef main():\n    commands = [{"name": "portscan", "func": portscan}, {"name": "ps", "func": portscan}]\n\n    connectToLocalServer()\n\n    while True:\n        os.system("cls")\n        printIps()\n        print()\n        print()\n        printCommands()\n        inputCommand = input(conf.connectedFormat.replace("PROTOCOL", " ".join(connectedProtocols)).replace("IPS", (conf.IpsSeperator).join(connectedIps)))\n        shiftCommandLine(f">{inputCommand}")\n\n        for command in commands:\n            if inputCommand.lower() == command["name"]:\n                command["func"]()\n\ndef portscan():\n    newIps = []\n\n    @conf.keyboard_soft_cancel()\n    def _scanPorts():\n        rootIp = ".".join(cm.hostIp().split(".")[0:3])\n\n        for ip in range(256):\n            os.system("cls")\n\n            testSocket = cm.createSocket()\n            testIp = rootIp + "." + str(ip)\n\n            printIps()\n            print()\n            print()\n            shiftCommandLine(f"Testing ip {testIp}")\n            printCommands()\n\n            try:\n                cm.connect(testSocket, testIp, 40500, 0.25)\n\n                cm.clientSendData(testSocket, "hostname")\n                hostname = cm.clientReceiveData(testSocket)\n                cm.clientSendData(testSocket, "disconnect")\n\n                alreadyFound = False\n                for discoveredIp in discoveredIps:\n                    if {"ip": testIp, "name": hostname} == discoveredIp:\n                        alreadyFound = True\n\n                if not alreadyFound:\n                    discoveredIps.append({"ip": testIp, "name": hostname})\n                    newIps.append({"ip": testIp, "name": hostname})\n            except:\n                pass\n\n            cm.disconnect(testSocket)\n\n    _scanPorts()\n\n    shiftCommandLine("")\n    shiftCommandLine("")\n    shiftCommandLine("New ips found:")\n    shiftCommandLine("")\n    for newIp in newIps:\n        shiftCommandLine(f"    {newIp[\'ip\']: <15}:     {newIp[\'name\']}")\n', 'config.py': 'def keyboard_soft_cancel(cancel_text=""):\n    def __make_wrapper(func):\n        def wrapper(*args, **kwargs):\n            try:\n                funcReturn = func(*args, **kwargs)\n\n                return funcReturn\n            except KeyboardInterrupt:\n                print()\n                print(cancel_text)\n\n        return wrapper\n    return __make_wrapper\n\nversion = 1\n\nlogoMain = """\n██████╗░██╗░░░██╗████████╗███████╗██████╗░██████╗░███████╗░█████╗░░█████╗░██╗░░██╗\n██╔══██╗╚██╗░██╔╝╚══██╔══╝██╔════╝██╔══██╗██╔══██╗██╔════╝██╔══██╗██╔══██╗██║░░██║\n██████╦╝░╚████╔╝░░░░██║░░░█████╗░░██████╦╝██████╔╝█████╗░░███████║██║░░╚═╝███████║\n██╔══██╗░░╚██╔╝░░░░░██║░░░██╔══╝░░██╔══██╗██╔══██╗██╔══╝░░██╔══██║██║░░██╗██╔══██║\n██████╦╝░░░██║░░░░░░██║░░░███████╗██████╦╝██║░░██║███████╗██║░░██║╚█████╔╝██║░░██║\n╚═════╝░░░░╚═╝░░░░░░╚═╝░░░╚══════╝╚═════╝░╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝░╚════╝░╚═╝░░╚═╝\n"""\nIPsPerLine = 5\nIpsSeperator = " -> "\nconnectedFormat = "(PROTOCOL) IPS >>>"\nmaxCommands = 25\ncommandLindWidth = 100\nconnectedRootIp = 1\n', 'connMan.py': 'import socket\n\nserverIp = None\n#tmpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nformat = "utf-8"\nheader = 64\n\ndef createSocket():\n    return socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ndef hostName():\n    return socket.gethostname()\n\ndef hostIp():\n    return socket.gethostbyname(hostName())\n\ndef bind(cSocket, port, overwriteIp=None):\n    global serverIp\n\n    if overwriteIp:\n        serverIp = overwriteIp\n    \n    cSocket.bind((serverIp, port))\n\ndef awaitConnection(cSocket):\n    cSocket.listen()\n\n    # Connection, (Address, Port)\n    return cSocket.accept()\n\ndef connect(cSocket, ip, port, timeout=None):\n    # Check to see if its IP or PC name\n    ip = socket.gethostbyname(ip)\n    addr = (ip, port)\n\n    cSocket.settimeout(timeout)\n    cSocket.connect(addr)\n\ndef serverSendData(connection, msg):\n    #try:\n    msg = msg.encode(format)\n    msgLenght = str(len(msg)).encode(format) + b"\\x00" * (header - (len(str(len(msg)).encode(format))))\n    connection.send(msgLenght)\n    connection.send(msg)\n    #except:\n    #    print("The connection was unexpectadly terminated")\n    #    exit()\n\ndef serverReceiveData(connection):\n    try:\n        lenght = connection.recv(header).decode(format)\n        lenght = str(lenght).replace(\'\\x00\', \'\')\n        data = connection.recv(int(lenght)).decode(format)\n\n        return data\n    except Exception as e:\n        print(f"The connection was unexpectadly terminated (error: {e})")\n        exit()\n\ndef clientSendData(cSocket, msg):\n    try:\n        msg = msg.encode(format)\n        msgLength = str(len(msg)).encode(format) + b"\\x00" * (header - (len(str(len(msg)).encode(format))))\n        cSocket.send(msgLength)\n        cSocket.send(msg)\n    except:\n        print("The connection was unexpectadly terminated")\n        exit()\n\ndef clientReceiveData(cSocket):\n    try:\n        legnth = cSocket.recv(header).decode(format)\n        legnth = str(legnth).replace(\'\\x00\', \'\')\n        data = cSocket.recv(int(legnth)).decode(format)\n\n        return data\n    except Exception as e:\n        print(f"The connection was unexpectadly terminated (error: {e})")\n        exit()\n\ndef disconnect(cSocket):\n    cSocket.close()\n\ndef requestSyncS(connection):\n    serverSendData(connection, "SYNC")\n    serverReceiveData(connection)\n\ndef requestSyncC():\n    clientSendData("SYNC")\n    clientReceiveData()\n\nserverIp = hostIp()\n', 'main.py': 'import config as conf\nimport os\nimport time\nimport client\n\ndef graduallyRemoveText(text, index):\n    for line in text.split("\\n"):\n        if index > 0:\n            index -= 1\n            print()\n            continue\n\n        print(line)\n\nos.system("cls")\n\nprint(conf.logoMain)\nconfirmation = input("Are you ready to start? (Y/n) >>>")\n\nif confirmation.lower() == "y" or confirmation == "":\n    for index in range(len(conf.logoMain.split("\\n")) + 1):\n        os.system("cls")\n        graduallyRemoveText(conf.logoMain, index)\n        time.sleep(0.25)\n\n    os.system("cls")\n    os.startfile("server.py")\n    client.main()\nelse:\n    exit()\n', 'server.py': 'import connMan as cm\nimport threading\n\nsocket = cm.createSocket()\ncm.bind(socket, 40500)\n\ndef handleConnection(connection, address):\n    print(f"New connection form {address[0]}")\n\n    while True:\n        message = cm.serverReceiveData(connection)\n        \n        match message:\n            case "local_hello":\n                print("Hello!")\n\n            case "disconnect":\n                print(f"{address[0]} disconnected")\n                return\n            case "hostname":\n                print(f"{address[0]} requested hostname")\n                cm.serverSendData(connection, cm.hostName())\n\nwhile True:\n    connection, address = cm.awaitConnection(socket)\n\n    thread = threading.Thread(target=handleConnection, args=(connection, address))\n    thread.start()\n'}
print(f"Unpacking {data['name']}...")

for key in data:
    if key != "name":
        print(f"Unpacking {key}")
        with open(key, "w", encoding="utf8") as file:
            file.write(data[key])

import os

os.startfile("main.py")
