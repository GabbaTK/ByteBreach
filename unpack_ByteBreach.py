data = {'autoUpdater.py': 'import config as conf\nfrom urllib.request import urlopen as uo\nimport os\n\nupdaterCode = """\nfrom urllib.request import urlopen as uo\nimport time\n\ntime.sleep(1)\n\ndownloadUrl = "https://raw.githubusercontent.com/GabbaTK/ByteBreach/main/unpack_ByteBreach.py"\n\ndownload = uo(downloadUrl)\ndownload = download.read()\nexec(download)\n"""\nversionUrl = "https://raw.githubusercontent.com/GabbaTK/ByteBreach/main/version.txt"\n\nprogramVersion = conf.version\nnewVersion = uo(versionUrl)\nnewVersion = eval(newVersion.read())\n\nif newVersion > programVersion:\n    print("A new version has been found, downloading...")\n\n    with open("update.py", "w") as update:\n        update.write(updaterCode)\n\n    os.startfile("update.py")\n', 'client.py': 'import connMan as cm\nimport config as conf\nimport os\nimport socket\nimport hackingModules\n\nlocalSocket = None\nconnectionSocket = None\ndiscoveredIps = [{"ip": cm.hostIp(), "name": cm.hostName()}]\ncommandLine = [""] * conf.maxCommands\nconnectedIps = [cm.hostIp()]\nconnectedProtocols = []\n\ndef connectToLocalServer():\n    global localSocket\n\n    print("Connecting to local server...")\n    print("If another window didnt start, try starting server.py")\n\n    localSocket = cm.createSocket()\n    cm.connect(localSocket, cm.hostIp(), 40500)\n\n    print("Connected!")\n\n    cm.clientSendData(localSocket, "local_hello")  \n\ndef checkLocalConnection():\n    if cm.clientSendData(localSocket, "local_ping") == False:\n        os.system("cls")\n        print(conf.dontCheat)\n        exit()\n\n    response = cm.clientReceiveData(localSocket)\n\n    if response == "local_active":\n        return\n    else:\n        os.system("cls")\n        print(conf.dontCheat)\n        exit()\n\ndef printUI():\n    printIps()\n    print()\n    print()\n    printCommands()\n\ndef printIps():\n    ipCounter = 0\n    for ip in discoveredIps:\n        print(conf.rawColor["CYAN"], end="")\n        print(ip["name"], end="   ")\n        print(conf.rawColor["WHITE"], end="")\n\n        ipCounter += 1\n\n        if ipCounter == conf.IPsPerLine:\n            print()\n\ndef printCommands():\n    print("-" * conf.commandLindWidth)\n\n    for command in commandLine:\n        print("|", end="")\n        print(command, end="")\n        print(" " * (conf.commandLindWidth - 2 - len(command)), end="")\n        print("|")\n\n    print("-" * conf.commandLindWidth)\n\ndef shiftCommandLine(newCommand):\n    for index, line in enumerate(commandLine):\n        if index == 0:\n            continue\n\n        commandLine[index - 1] = line\n\n    commandLine[-1] = newCommand \n\ndef main():\n    commands = [{"name": "portscan", "func": portscan}, {"name": "ps", "func": portscan}, {"name": "connect", "func": connect}, {"name": "c", "func": connect}, {"name": "cn", "func": connect}, {"name": "disconnect", "func": disconnect}, {"name": "dc", "func": disconnect}, {"name": "udphack", "func": udphack}]\n\n    connectToLocalServer()\n\n    while True:\n        os.system("cls")\n        printUI()\n        inputCommand = input(conf.connectedFormat.replace("PROTOCOL", f"{conf.rawColor[\'GREEN\']}{\' \'.join(connectedProtocols)}{conf.rawColor[\'WHITE\']}").replace("IPS", (conf.IpsSeperator).join(connectedIps))).split(" ")\n        args = inputCommand[1:]\n        inputCommand = inputCommand[0]\n        checkLocalConnection()\n        shiftCommandLine(f">{inputCommand} {\' \'.join(args)}")\n\n        for command in commands:\n            if inputCommand.lower() == command["name"]:\n                command["func"](args)\n\ndef portscan(_):\n    newIps = []\n\n    @conf.keyboard_soft_cancel()\n    def _scanPorts():\n        rootIp = ".".join(cm.hostIp().split(".")[0:3])\n\n        for ip in range(256):\n            os.system("cls")\n\n            testSocket = cm.createSocket()\n            testIp = rootIp + "." + str(ip)\n\n            shiftCommandLine(f"Testing ip {testIp}")\n            printUI()\n\n            try:\n                cm.connect(testSocket, testIp, 40500, 0.25)\n\n                cm.clientSendData(testSocket, "hostname")\n                hostname = cm.clientReceiveData(testSocket)\n                cm.clientSendData(testSocket, "disconnect")\n\n                alreadyFound = False\n                for discoveredIp in discoveredIps:\n                    if {"ip": testIp, "name": hostname} == discoveredIp:\n                        alreadyFound = True\n\n                if not alreadyFound:\n                    discoveredIps.append({"ip": testIp, "name": hostname})\n                    newIps.append({"ip": testIp, "name": hostname})\n            except:\n                pass\n\n            cm.disconnect(testSocket)\n\n    _scanPorts()\n\n    shiftCommandLine("")\n    shiftCommandLine("")\n    shiftCommandLine("New ips found:")\n    shiftCommandLine("")\n    for newIp in newIps:\n        shiftCommandLine(f"    {newIp[\'ip\']: <15}:     {newIp[\'name\']}")\n\ndef connect(args):\n    global connectionSocket\n\n    if connectionSocket != None:\n        shiftCommandLine("You must disconnect from the current pc before connecting to another one!")\n        return\n    \n    if args[0] == discoveredIps[0]["name"] or args[0] == discoveredIps[0]["ip"]:\n        shiftCommandLine("You cannot connect to yourself!")\n        return\n\n    connectionSocket = cm.createSocket()\n    ip = args[0]\n\n    discovered = False\n    for discoveredIp in discoveredIps:\n        if discoveredIp["ip"] == cm.getHostIp(ip) or discoveredIp["name"] == cm.getHostIp(ip):\n            discovered = True\n\n    os.system("cls")\n    shiftCommandLine(f"Connecting to {ip}")\n    printUI()\n\n    try:\n        cm.connect(connectionSocket, ip, 40500, 5)\n\n        connectedIps.append(cm.getHostIp(ip))\n\n        if not discovered:\n            cm.clientSendData(connectionSocket, "hostname")\n            hostname = cm.clientReceiveData(connectionSocket)\n\n            discoveredIps.append({"name": hostname, "ip": ip})\n    except TimeoutError:\n        shiftCommandLine(f"Failed to connect to {ip}")\n    except socket.gaierror:\n        shiftCommandLine("Computer doesn\'t exist")\n\ndef disconnect(_):\n    global connectionSocket, connectedIps, connectedProtocols\n\n    if connectionSocket == None:\n        shiftCommandLine("You cannot disconnect any further!")\n        return\n    \n    shiftCommandLine(f"Disconnecting from {connectedIps[1]}")\n\n    cm.clientSendData(connectionSocket, "disconnect")\n    cm.disconnect(connectionSocket)\n    \n    connectionSocket = None\n    connectedIps = [connectedIps[0]]\n    connectedProtocols = []\n\ndef udphack(_):\n    global connectedProtocols\n\n    if "UDP" in connectedProtocols:\n        shiftCommandLine("You cannot hack UDP when it is already hacked")\n        return\n\n    if connectionSocket == None:\n        shiftCommandLine("You must be connected to a computer to hack it")\n        return\n    \n    cm.clientSendData(connectionSocket, "hack_udp")\n    pakcets, infectedPackets, infectedByte = hackingModules.udpClient()\n    \n    parsedPackets = []\n    for line in pakcets:\n        parsedPackets.append("-".join(line))\n    parsedPackets = "|".join(parsedPackets)\n\n    cm.clientSendData(connectionSocket, "hack_udp_packets")\n    cm.clientSendData(connectionSocket, parsedPackets)\n    cm.clientSendData(connectionSocket, "hack_udp_infected")\n    cm.clientSendData(connectionSocket, "-".join(infectedPackets))\n    cm.clientSendData(connectionSocket, "hack_udp_byte")\n    cm.clientSendData(connectionSocket, infectedByte)\n\n    cm.clientSendData(connectionSocket, "hack_udp_start")\n\n    shiftCommandLine("")\n    shiftCommandLine("Infected packets have been sent to the victim computer")\n    shiftCommandLine("Waiting for hack result...")\n\n    printUI()\n\n    # fail is for server failing and suc is for server securing\n    result = cm.clientReceiveData(connectionSocket)\n\n    if result == "suc":  \n        shiftCommandLine("")\n        shiftCommandLine("The hack has failed")\n    elif result == "fail":\n        shiftCommandLine("")\n        shiftCommandLine("The hack has succeded")\n\n        connectedProtocols.append("UDP")\n', 'config.py': 'def keyboard_soft_cancel(cancel_text=""):\n    def __make_wrapper(func):\n        def wrapper(*args, **kwargs):\n            try:\n                funcReturn = func(*args, **kwargs)\n\n                return funcReturn\n            except KeyboardInterrupt:\n                print()\n                print(cancel_text)\n\n        return wrapper\n    return __make_wrapper\n\nversion = 5\n\nrawColor = {\n    "GRAY": "\\033[90m",\n    "RED": "\\033[91m",\n    "GREEN": "\\033[92m",\n    "YELLOW": "\\033[93m",\n    "BLUE": "\\033[94m",\n    "PINK": "\\033[95m",\n    "CYAN": "\\033[96m",\n    "WHITE": "\\033[97m"\n}\n\nlogoMain = """\n\\033[91m██████╗░██╗░░░██╗████████╗███████╗\\033[96m██████╗░██████╗░███████╗░█████╗░░█████╗░██╗░░██╗\\033[97m\n\\033[91m██╔══██╗╚██╗░██╔╝╚══██╔══╝██╔════╝\\033[96m██╔══██╗██╔══██╗██╔════╝██╔══██╗██╔══██╗██║░░██║\\033[97m\n\\033[91m██████╦╝░╚████╔╝░░░░██║░░░█████╗░░\\033[96m██████╦╝██████╔╝█████╗░░███████║██║░░╚═╝███████║\\033[97m\n\\033[91m██╔══██╗░░╚██╔╝░░░░░██║░░░██╔══╝░░\\033[96m██╔══██╗██╔══██╗██╔══╝░░██╔══██║██║░░██╗██╔══██║\\033[97m\n\\033[91m██████╦╝░░░██║░░░░░░██║░░░███████╗\\033[96m██████╦╝██║░░██║███████╗██║░░██║╚█████╔╝██║░░██║\\033[97m\n\\033[91m╚═════╝░░░░╚═╝░░░░░░╚═╝░░░╚══════╝\\033[96m╚═════╝░╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝░╚════╝░╚═╝░░╚═╝\\033[97m\n"""\ndontCheat = """\n▒█▀▀▄ █▀▀█ █▀▀▄ ▀▀█▀▀ \u3000 ▀▀█▀▀ █▀▀█ █░░█ \u3000 ▀▀█▀▀ █▀▀█ \u3000 █▀▀ █░░█ █▀▀ █▀▀█ ▀▀█▀▀ ░░ \n▒█░▒█ █░░█ █░░█ ░░█░░ \u3000 ░░█░░ █▄▄▀ █▄▄█ \u3000 ░░█░░ █░░█ \u3000 █░░ █▀▀█ █▀▀ █▄▄█ ░░█░░ ▄▄ \n▒█▄▄▀ ▀▀▀▀ ▀░░▀ ░░▀░░ \u3000 ░░▀░░ ▀░▀▀ ▄▄▄█ \u3000 ░░▀░░ ▀▀▀▀ \u3000 ▀▀▀ ▀░░▀ ▀▀▀ ▀░░▀ ░░▀░░ ░█ \n\n█▀▀ █▀▀ █▀▀█ ▀█░█▀ █▀▀ █▀▀█ ░ █▀▀█ █░░█ \u3000 █▀▄▀█ █░░█ █▀▀ ▀▀█▀▀ \u3000 █▀▀▄ █▀▀ \u3000 █▀▀█ █░░█ █▀▀▄ █▀▀▄ ░▀░ █▀▀▄ █▀▀▀\n▀▀█ █▀▀ █▄▄▀ ░█▄█░ █▀▀ █▄▄▀ ▄ █░░█ █▄▄█ \u3000 █░▀░█ █░░█ ▀▀█ ░░█░░ \u3000 █▀▀▄ █▀▀ \u3000 █▄▄▀ █░░█ █░░█ █░░█ ▀█▀ █░░█ █░▀█\n▀▀▀ ▀▀▀ ▀░▀▀ ░░▀░░ ▀▀▀ ▀░▀▀ █ █▀▀▀ ▄▄▄█ \u3000 ▀░░░▀ ░▀▀▀ ▀▀▀ ░░▀░░ \u3000 ▀▀▀░ ▀▀▀ \u3000 ▀░▀▀ ░▀▀▀ ▀░░▀ ▀░░▀ ▀▀▀ ▀░░▀ ▀▀▀▀\n"""\nIPsPerLine = 5\nIpsSeperator = f"{rawColor[\'RED\']} -> {rawColor[\'WHITE\']}"\nconnectedFormat = "(PROTOCOL) IPS >>>"\nmaxCommands = 25\ncommandLindWidth = 100\n\nhackUdpWidth = 6\nhackUdpHeight = 8\nhackUdpInfectedBytes = 6\n', 'connMan.py': 'import socket\n\nserverIp = None\n#tmpSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nformat = "utf-8"\nheader = 64\n\ndef createSocket():\n    return socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ndef hostName():\n    return socket.gethostname()\n\ndef hostIp():\n    return socket.gethostbyname(hostName())\n\ndef getHostIp(name):\n    return socket.gethostbyname(name)\n\ndef bind(cSocket, port, overwriteIp=None):\n    global serverIp\n\n    if overwriteIp:\n        serverIp = overwriteIp\n    \n    cSocket.bind((serverIp, port))\n\ndef awaitConnection(cSocket):\n    cSocket.listen()\n\n    # Connection, (Address, Port)\n    return cSocket.accept()\n\ndef connect(cSocket, ip, port, timeout=None):\n    # Check to see if its IP or PC name\n    ip = socket.gethostbyname(ip)\n    addr = (ip, port)\n\n    cSocket.settimeout(timeout)\n    cSocket.connect(addr)\n    cSocket.settimeout(None)\n\ndef serverSendData(connection, msg):\n    #try:\n    msg = msg.encode(format)\n    msgLength = str(len(msg)).encode(format) + b"\\x00" * (header - (len(str(len(msg)).encode(format))))\n    connection.send(msgLength)\n    connection.send(msg)\n    #except:\n    #    print("The connection was unexpectadly terminated")\n    #    exit()\n\ndef serverReceiveData(connection):\n    try:\n        length = connection.recv(header).decode(format)\n        length = str(length).replace(\'\\x00\', \'\')\n        data = connection.recv(int(length)).decode(format)\n\n        return data\n    except Exception as e:\n        print(f"The connection was unexpectadly terminated (error: {e})")\n        exit()\n\ndef clientSendData(cSocket, msg):\n    try:\n        msg = msg.encode(format)\n        msgLength = str(len(msg)).encode(format) + b"\\x00" * (header - (len(str(len(msg)).encode(format))))\n        cSocket.send(msgLength)\n        cSocket.send(msg)\n    except:\n        print("The connection was unexpectadly terminated")\n\n        return False\n\ndef clientReceiveData(cSocket):\n    try:\n        legnth = cSocket.recv(header).decode(format)\n        legnth = str(legnth).replace(\'\\x00\', \'\')\n        data = cSocket.recv(int(legnth)).decode(format)\n\n        return data\n    except Exception as e:\n        print(f"The connection was unexpectadly terminated (error: {e})")\n        exit()\n\ndef disconnect(cSocket):\n    cSocket.close()\n\ndef requestSyncS(connection):\n    serverSendData(connection, "SYNC")\n    serverReceiveData(connection)\n\ndef requestSyncC():\n    clientSendData("SYNC")\n    clientReceiveData()\n\nserverIp = hostIp()\n', 'hackingModules.py': 'import udpBreach\n\ndef udpClient():\n    return udpBreach.client()\n\ndef udpServer(packets, infectedPackets, infectedByte):\n    return udpBreach.server(packets, infectedPackets, infectedByte)\n', 'main.py': 'import os\ntry:\n    import pytimedinput\nexcept ImportError:\n    os.system("pip install pytimedinput")\n\nimport config as conf\nimport time\nimport client\nimport autoUpdater\n\nif autoUpdater.programVersion < autoUpdater.newVersion:\n    exit()\n\ndef graduallyRemoveText(text, index):\n    for line in text.split("\\n"):\n        if index > 0:\n            index -= 1\n            print()\n            continue\n\n        print(line)\n\nif os.path.exists("update.py"):\n    os.remove("update.py")\n\nos.system("cls")\n\nprint(conf.logoMain)\nconfirmation = input("Are you ready to start? (Y/n) >>>")\n\nif confirmation.lower() == "y" or confirmation == "":\n    for index in range(len(conf.logoMain.split("\\n")) + 1):\n        os.system("cls")\n        graduallyRemoveText(conf.logoMain, index)\n        time.sleep(0.25)\n\n    os.system("cls")\n    os.startfile("server.py")\n    client.main()\nelse:\n    exit()\n', 'server.py': 'import connMan as cm\nimport threading\nimport hackingModules\nimport config as conf\n\nsocket = cm.createSocket()\ncm.bind(socket, 40500)\n\ndef handleConnection(connection, address):\n    global udpPackets\n    global udpInfectedPackets\n    global udpInfectedByte\n\n    print(f"New connection from {address[0]}")\n\n    while True:\n        message = cm.serverReceiveData(connection)\n        \n        match message:\n            case "local_hello":\n                print("Hello!")\n            case "local_ping":\n                cm.serverSendData(connection, "local_active")\n\n            case "disconnect":\n                print(f"{address[0]} disconnected")\n                return\n            case "hostname":\n                print(f"{address[0]} requested hostname")\n                cm.serverSendData(connection, cm.hostName())\n            case "hack_udp":\n                udpPackets = ""\n                udpInfectedPackets = ""\n                udpInfectedByte = ""\n\n                print(f"{conf.rawColor[\'RED\']}UDP HACK DETECTED{conf.rawColor[\'WHITE\']}")\n                print(f"{conf.rawColor[\'RED\']}WAITING FOR MALICIOUS PACKET{conf.rawColor[\'WHITE\']}")\n            case "hack_udp_packets":\n                udpPackets = cm.serverReceiveData(connection)\n                udpPackets = udpPackets.split("|")\n                for index, packet in enumerate(udpPackets):\n                    udpPackets[index] = packet.split("-")\n            case "hack_udp_infected":\n                udpInfectedPackets = cm.serverReceiveData(connection)\n                udpInfectedPackets = udpInfectedPackets.split("-")\n            case "hack_udp_byte":\n                udpInfectedByte = cm.serverReceiveData(connection)\n            case "hack_udp_start":\n                result = hackingModules.udpServer(udpPackets, udpInfectedPackets, udpInfectedByte)\n\n                if not result:\n                    print(f"{conf.rawColor[\'RED\']}UDP PORT BREACHED{conf.rawColor[\'WHITE\']}")\n                    cm.serverSendData(connection, "fail")\n                else:\n                    print(f"{conf.rawColor[\'GREEN\']}UDP PORT SECURED{conf.rawColor[\'WHITE\']}")\n                    cm.serverSendData(connection, "suc")\n\nwhile True:\n    connection, address = cm.awaitConnection(socket)\n\n    thread = threading.Thread(target=handleConnection, args=(connection, address))\n    thread.start()\n', 'udpBreach.py': 'import random\nimport config as conf\nimport os\nimport pytimedinput\nimport copy\n\nletters = ["A", "B", "C", "D", "E", "F", "G", "H"]\nmoderatedByAV = [\n    "|------|",\n    "|      |",\n    "|SECURE|",\n    "|  BY  |",\n    "|  AV  |",\n    "|      |",\n    "|      |",\n    "|------|"\n]\n\ndef client():\n    packets = []\n    infectedPackets = []\n\n    for _ in range(conf.hackUdpHeight):\n        subPacket = []\n\n        for _ in range(conf.hackUdpWidth):\n            byte = ""\n\n            for _ in range(8):\n                byte += str(round(random.random()))\n            \n            subPacket.append(byte)\n\n        packets.append(subPacket)\n\n    infectedByte = byteExists(packets)\n\n    for index in range(conf.hackUdpInfectedBytes):\n        while True:\n            os.system("cls")\n            clientPrintTable(packets, infectedPackets)\n            byte = input(f"Enter byte address to infect ({conf.hackUdpInfectedBytes - index} left) >>>").upper()\n\n            if byte[0] in letters and byte[1] in ["1", "2", "3", "4", "5", "6"]:\n                address = (letters.index(byte[0]), int(byte[1]) - 1)\n\n                if str(address[0]) + str(address[1]) not in infectedPackets:\n                    infectedPackets.append(str(address[0]) + str(address[1]))\n                    packets[address[0]][address[1]] = infectedByte\n\n                    break\n    \n    os.system("cls")\n    # clientPrintTable(packets, infectedPackets)\n\n    return packets, infectedPackets, infectedByte\n\ndef server(packets, infectedPackets, infectedByte):\n    clearedBytes = []\n    antivirusColoums = [random.randint(0, 5), random.randint(0, 5)]\n    while True:\n        if antivirusColoums[0] == antivirusColoums[1]:\n            antivirusColoums[1] = random.randint(0, 5)\n        else:\n            break\n\n    packets = joinTables(packets, moderatedByAV, antivirusColoums[0])\n    packets = joinTables(packets, moderatedByAV, antivirusColoums[1])\n\n    unsecuredPackets = []\n    for byte in infectedPackets:\n        if int(byte[1]) not in antivirusColoums:\n            unsecuredPackets.append(byte)\n\n    for _ in range(len(unsecuredPackets)):\n        while True:\n            os.system("cls")\n\n            print(f"You have {conf.rawColor[\'GREEN\']}30{conf.rawColor[\'WHITE\']} seconds")\n            print(f"Find these infected bytes: {conf.rawColor[\'RED\']}{infectedByte}{conf.rawColor[\'WHITE\']}")\n            serverPrintTable(packets)\n\n            userInput, timedout = pytimedinput.timedInput("Enter byte address to remove (ex. B4) >>>", 30, False)\n\n            if timedout:\n                return False\n\n            userInput = userInput.upper()\n            if userInput[0] in letters and userInput[1] in ["1", "2", "3", "4", "5", "6"]:\n                address = str(letters.index(userInput[0])) + str(int(userInput[1]) - 1)\n                if address not in clearedBytes:\n                    if int(address[1]) not in antivirusColoums:\n                        clearedBytes.append(address)\n                        packets[int(address[0])][int(address[1])] = conf.rawColor["RED"] + packets[letters.index(userInput[0])][int(userInput[1]) - 1] + conf.rawColor["WHITE"]\n\n                        break\n\n    if clearedBytes == unsecuredPackets:\n        return True\n    else:\n        return False\n\ndef serverPrintTable(tableIn):\n    table = copy.deepcopy(tableIn)\n\n    print(f"{conf.rawColor[\'CYAN\']}     1        2        3        4        5        6{conf.rawColor[\'WHITE\']}")\n\n    for index, line in enumerate(table):\n        print(f"{conf.rawColor[\'CYAN\']}{letters[index]}{conf.rawColor[\'WHITE\']}", end=" ")\n        print(" ".join(line))\n\ndef joinTables(tableA, tableB, joinColoum):\n    for row in range(8):\n        tableA[row][joinColoum] = tableB[row]\n\n    return tableA\n\ndef clientPrintTable(tableIn, infectedTable):\n    table = copy.deepcopy(tableIn)\n\n    for infected in infectedTable:\n        table[int(infected[0])][int(infected[1])] = conf.rawColor["RED"] + table[int(infected[0])][int(infected[1])] + conf.rawColor["WHITE"]\n\n    print(f"{conf.rawColor[\'CYAN\']}     1        2        3        4        5        6{conf.rawColor[\'WHITE\']}")\n\n    for index, line in enumerate(table):\n        print(f"{conf.rawColor[\'CYAN\']}{letters[index]}{conf.rawColor[\'WHITE\']}", end=" ")\n        print(" ".join(line))\n\ndef listOfBytes(table):\n    byteList = []\n\n    for line in table:\n        for byte in line:\n            byteList.append(byte)\n\n    return byteList\n\ndef byteExists(table):\n    byteList = listOfBytes(table)\n\n    while True:\n        byte = ""\n\n        for _ in range(8):\n            byte += str(round(random.random()))\n\n        if byte not in byteList:\n            return byte\n'}
print("Unpacking ByteBreach...")

for key in data:
    if key != "name":
        print(f"Unpacking {key}")
        with open(key, "w", encoding="utf8") as file:
            file.write(data[key])

import os

os.startfile("main.py")
